\documentclass[a4paper, 12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[scale=1,angle=0,opacity=1,color=black!60]{background}
\usepackage{tikzpagenodes}
\usepackage{lastpage}
\usepackage{lmodern}
\usepackage{float}
\usepackage[textwidth=420pt,textheight=630pt]{geometry}
\setlength{\oddsidemargin}{15.5pt}
%\usepackage[none]{hyphenat} %no cortar palabras

\usepackage[spanish, activeacute]{babel} %Definir idioma español
\usepackage[utf8]{inputenc} %Codificacion utf-8
\backgroundsetup{contents={}} %Saca el 'draft'
\definecolor{mygray}{rgb}{0.95,0.95,0.95}

\usepackage{listings}
\lstset{
    basicstyle=\footnotesize,
    backgroundcolor=\color{mygray},         
    breaklines=true,
    breakatwhitespace=true,   
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},              
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    language=C,
    frame=none,
	title=\lstname
}

\def\labelitemi{$\bullet$}

\begin{document}		
	% TÍTULO, AUTORES Y FECHA
	\begin{titlepage}
		\vspace*{\fill}
		\begin{center}
			\Large 75.08 Sistemas Operativos \\
			\Huge Entrega Kernel 2 \\
			\bigskip\bigskip\bigskip
			\large\textbf{Nombre y Apellido:} Sebastián Ezequiel Blanco \\
			\textbf{Padrón:} 98539 \\
			\large\textbf{Nombre y Apellido:} Martín Nicolás Pérez \\
			\textbf{Padrón:} 97378 \\
			\textbf{Fecha de Entrega:} 22/06/2018\\
			\textbf{GitHub:} https://github.com/BlancoSebastianEzequiel/LabKernel2\\

		\end{center}
		\vspace*{\fill}
	\end{titlepage}
	\pagenumbering{arabic}
	\newpage
			
	% ÍNDICE
	\tableofcontents
	\newpage
	%\pagenumbering{arabic}
	
	\section{Creación de stacks en el kernel}
		% EJ KERN2 STACK
		\subsection{Ej: kern2-stack}
		\begin{itemize}
			\item \textit{Explicar: ¿qué significa “estar alineado”?\\}
		Estar alineado significa que nuestro espacio de memoria será
		múltiplo de un numero que es el que se utiliza para alinear, es decir,
		que los primeros n bit empezaran en cero.\\\\
			\item \textit{Mostrar la sintaxis de C/GCC para alinear a 32 bits
			el arreglo kstack anterior.\\}
\begin{lstlisting}
	unsigned char stack1[8192] __attribute__((aligned(32)));
\end{lstlisting}
			\item \textit{A qué valor se está inicializando kstack?
			¿Varía entre la versión C y la versión ASM? (Leer la documentación
			de as sobre la directiva .space.)\\}
		Esta inicializado en cero ya que el segundo argumento de space que es
		fill no es especificado, y en tal caso su valor es cero. Si varia en la
		version c ya que en esta ultima el valor de la stack en C tiene datos
		basura\\\\
			\item \textit{Explicar la diferencia entre las directivas .align y
			.p2align de as, y mostrar cómo alinear el stack del kernel a 4 KiB
			usando cada una de ellas.\\}
		Ambas rellenean el contador de ubicación (en la subsección actual) con
		un límite de almacenamiento particular. La primera expresión
		(que debe ser absoluta) es la alineación requerida. La diferencia es que
		align alinea por el valor que se le pasa y p2align alinea por el valor
		que se le pasa como potencia de dos, es decir que align 4096 alinea a
		4Kb y p2align 12 también.\\\\
			\item \textit{Finalmente: mostrar en una sesión de GDB los valores
			de esp y eip al entrar en kmain, así como los valores almacenados
			en el stack en ese momento.\\}
			gdb -q -s kern2 -n -ex 'target remote 127.0.0.1:7508'\\
			Leyendo símbolos desde kern2 \ldots hecho.\\
			Remote debugging using 127.0.0.1:7508\\
			0x0000fff0 in ?? ()\\
			(gdb) b kmain\\
			Punto de interrupción 1 at 0x100129: file kern2.c, line 61.\\
			(gdb) p \$esp\\
			\$1 = (void *) 0x0\\
			(gdb) p/x \$eip\\
			\$3 = 0xfff0\\
			(gdb) info frame\\
			Stack level 0, frame at 0x0:\\
			eip = 0xfff0; saved eip = <unavailable>\\
			Outermost frame: outermost\\
			Arglist at unknown address.\\
			Locals at unknown address, Previous frame's sp in esp\\
		\end{itemize}

		\subsection{Ej: kern2-cmdline}
		\begin{itemize}
			\item \textit{Mostrar cómo implementar la misma concatenación, de
			manera correcta, usando strncat(3).}
\begin{lstlisting}
	char *strncat(char *dest, const char *src, size_t n) {
		size_t dest_len = strlen(dest);
		size_t i;
		for (i = 0 ; i < n && src[i] != '\0' ; i++) {
			dest[dest_len + i] = src[i];
		}
		dest[dest_len + i] = '\0';
		return dest;
	}
\end{lstlisting}
			\item \textit{Explicar cómo se comporta strlcat(3) si, erróneamente,
			se declarase buf con tamaño 12. ¿Introduce algún error el código?\\}
			No introduce error. Esta función recibe un tercer parámetro que es
			el tamaño máximo que la cadena final tendrá. En este caso, si buf
			tuviera tamaño 12, no seria un problema porque vemos que como tercer
			parámetro recibe el tamaño de la cadena destino, mas el tamaño de la
			cadena fuente mas uno. Entonces como el tamaño máximo es mayor
			tamaño de la cadena destino, se copia la cadena fuente a la destino.
			\item \textit{Compilar el siguiente programa, y explicar por qué se
			imprimen dos líneas distintas, en lugar de la misma dos veces:\\}
\begin{lstlisting}
	#include <stdio.h>
	static void printf_sizeof_buf(char buf[256]) {
		printf("sizeof buf = %zu\n", sizeof buf);
	}
	int main(void) {
		char buf[256];
		printf("sizeof buf = %zu\n", sizeof buf);
		printf_sizeof_buf(buf);
	}
\end{lstlisting}
			Esto es erróneo porque al tener como argumento char buf[256]
			recibe como parámetro un puntero y a este le aplica el operador
			size of, lo cual te da como resultado cuanto ocupa un puntero en
			memoria. Que en general pueden ser 4 u 8 bytes. En cambio, el otro
			caso funciona porque recibe como parámetro el puntero a un buffer y
			lo que hace es calcular las distancia entre este puntero y el
			ultimo caracter. Para que ambos resulten iguales la funcion
			debiera tener como parametro char* buff solamente.
		\end{itemize}
	\section{Concurrencia cooperativa}
		\subsection{Ej: kern2-swap}
		\begin{itemize}
			\item \textit{Explicar, para el stack de cada contador, cuántas
			posiciones se asignan, y qué representa cada una.\\}
			En el caso del segundo stack, se pasan los tres argumentos que la
			función contado\_yield necesita, luego se pasa un puntero a la función
			exit y luego un puntero a la función contador\_yield. Finalmente se
			inicializan las cuatro posiciones siguientes donde se guardaran los
			cuatro registros callee saved. Esto se hace porque cunado se cambia de
			stack, este retira de la stack dichos registros. Por lo tanto
			luego de ello apuntaría a contador\_yield.\\
			Cuando se hace el swap en la función task\_swap y se hace el switch
			entre stacks, la stack actual apunta a la segunda stack. Le saca los
			cuatro registros callee saved y queda apuntando a la función
			contador\_yield. Por lo tanto cuando ejecuta la instrucción ret salta a
			la función contador\_yield. En caso de que el segundo contador termine
			antes, cuando termina el loop principal, salta a otra función de retorno
			que en este caso es la que se guardo antes  y que seria exit.\\
			En el caso del primer contador solo se guardan los tres parámetros. No
			es necesario guardar direcciones de retorno ya que es con este stack que
			se llama a la función, por lo tanto cuando se hace un call a
			contador\_yield se guarda la dirección de retorno en la cuata posición
			del stack.
		\end{itemize}
	\section{Interrupciones: reloj y teclado}
		\subsection{Ej: kern2-idt}
		\begin{itemize}
			\item \textit{¿Cuántos bytes ocupa una entrada en la IDT?\\}
			Aqui la respuesta\\
			\item \textit{¿Cuántas entradas como máximo puede albergar la IDT?\\}
			Aqui la respuesta\\
			\item \textit{¿Cuál es el valor máximo aceptable para el campo limit
			del registro IDTR?\\}
			Aqui la respuesta\\
			\item \textit{Indicar qué valor exacto tomará el campo limit para
			una IDT de 64 descriptores solamente.\\}
			Aqui la respuesta\\
			\item \textit{Consultar la sección 6.1 y explicar la diferencia
			entre interrupciones (§6.3) y excepciones (§6.4).\\}
			Aqui la respuesta\\
		\end{itemize}
		\subsection{Ej: kern2-isr}
			\subsubsection{Sesión de GDB}
			Se debe seguir el mismo guión dos veces:\\
			\begin{itemize}
				\item \textit{versión A: usando esta implementación aumentada
				del manejador:}
\begin{lstlisting}
	.globl breakpoint
	breakpoint:
	nop
	test %eax, %eax
	iret
\end{lstlisting}
				Aqui la sesion de gdb\\
				\item \textit{Versión B: con el mismo manejador, pero cambiando
				la instrucción IRET por una instrucción RET.\\}
				Aqui la sesion de gdb\\
				\item \textit{Para cada una de las siguientes maneras de
				guardar/restaurar registros en breakpoint, indicar si es
				correcto (en el sentido de hacer su ejecución “invisible”), y
				justificar por qué:}
				\begin{itemize}
					\item Opcion A
\begin{lstlisting}
	breakpoint:
	pusha

	call vga_write2
	popa
	iret
\end{lstlisting}
					\item Opcion B
\begin{lstlisting}
	breakpoint:
	push %eax
	push %edx
	push %ecx

	call vga_write2
	pop %ecx
	pop %edx
	pop %eax
	iret
\end{lstlisting}
					\item Opcion C
\begin{lstlisting}
	breakpoint:
	push %ebx
	push %esi
	push %edi

	call vga_write2
	pop %edi
	pop %esi
	pop %ebx
	iret
\end{lstlisting}
\end{itemize}
					La opcion correcta es la B, ya que al llamar a la funcion,
					se supone que los registros callee saved, son salvados de
					manera tal que al volver de la funcion, estos mantienen
					su valor. En cambio, los registros caller saved no. Por lo
					tanto, la opcion A hace trabajo de mas al salvar todos los
					registros y la C no funcionaria ya que salva los registros
					callee saved que no es necesario ya que de eso se encarga la
					funcion llamada pero no salva los caller saved y al volver
					se podria perder si valor.\\
			\end{itemize}
\end{document}